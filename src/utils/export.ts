import { TimeSlot, TasteItem } from '../types';

export const generateCalendarText = (dayPlan: TimeSlot[], cityName: string, date: string = new Date().toISOString().split('T')[0]): string => {
  const events = dayPlan.filter(slot => slot.item);
  
  let calendarText = `BEGIN:VCALENDAR\nVERSION:2.0\nPRODID:-//vibetrail//EN\nCALSCALE:GREGORIAN\n\n`;
  
  events.forEach(slot => {
    if (slot.item) {
      const startTime = slot.time.replace(/[^\d]/g, '').padStart(4, '0');
      const startDateTime = `${date.replace(/-/g, '')}T${startTime}00`;
      
      calendarText += `BEGIN:VEVENT\n`;
      calendarText += `DTSTART:${startDateTime}\n`;
      calendarText += `SUMMARY:${slot.item.name}\n`;
      calendarText += `DESCRIPTION:${slot.item.description}\\n\\n${slot.explanation || ''}\n`;
      calendarText += `LOCATION:${slot.item.location}\n`;
      calendarText += `END:VEVENT\n\n`;
    }
  });
  
  calendarText += `END:VCALENDAR`;
  
  return calendarText;
};

export const downloadCalendar = (dayPlan: TimeSlot[], cityName: string): void => {
  const calendarText = generateCalendarText(dayPlan, cityName);
  const blob = new Blob([calendarText], { type: 'text/calendar' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `tastetrails-${cityName.toLowerCase()}-plan.ics`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// Export plan function for selected items (used in Plan page)
export const exportPlan = async (selectedItems: TasteItem[], cityName: string, vibeInput: string): Promise<void> => {
  const date = new Date().toISOString().split('T')[0];
  const planText = generatePlanText(selectedItems, cityName, vibeInput, date);
  
  // Create and download as a text file
  const blob = new Blob([planText], { type: 'text/plain' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `vibetrail-plan-${cityName.toLowerCase()}-${date}.txt`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

// Generate plan text from selected items
export const generatePlanText = (selectedItems: TasteItem[], cityName: string, vibeInput: string, date: string): string => {
  const categoryGroups = selectedItems.reduce((groups, item) => {
    const category = item.category || 'other';
    if (!groups[category]) {
      groups[category] = [];
    }
    groups[category].push(item);
    return groups;
  }, {} as { [key: string]: TasteItem[] });

  const categoryNames: { [key: string]: string } = {
    food: 'Food & Dining',
    activity: 'Things to Do',
    movie: 'Movies',
    tv_show: 'TV Shows',
    artist: 'Music',
    book: 'Books',
    podcast: 'Podcasts',
    videogame: 'Games',
    destination: 'Destinations',
    other: 'Other'
  };

  let planText = `VibeTrail - Your Perfect Day Plan\n`;
  planText += `=======================================\n\n`;
  planText += `City: ${cityName}\n`;
  planText += `Date: ${new Date(date).toLocaleDateString()}\n`;
  planText += `Your Vibe: "${vibeInput}"\n`;
  planText += `Total Recommendations: ${selectedItems.length}\n\n`;

  Object.entries(categoryGroups).forEach(([category, items]) => {
    planText += `${categoryNames[category] || category.toUpperCase()}\n`;
    planText += `${'='.repeat((categoryNames[category] || category).length)}\n\n`;
    
    items.forEach((item, index) => {
      planText += `${index + 1}. ${item.name}\n`;
      if (item.description) {
        planText += `   Description: ${item.description}\n`;
      }
      if (item.location) {
        planText += `   Location: ${item.location}\n`;
      }
      planText += `   Match Score: ${Math.round(item.tasteStrength * 100)}%\n`;
      if (item.whyItFits) {
        planText += `   Why it fits: ${item.whyItFits}\n`;
      }
      planText += `\n`;
    });
    planText += `\n`;
  });

  planText += `Generated by VibeTrail - AI-powered cultural intelligence\n`;
  planText += `https://vibetrail.com\n`;
  
  return planText;
};